\subsection{Generator}
The generator is the last step of the code generator because it does not convert the query language into bytecode or similar, but into another language, in this case, \ac{SQL}. For this purpose, the generator is similarly structured to the parser, except that it receives an \ac{AST} as input instead of output and generates a string from it.\\
In Transact-\ac{SQL} there are two ways to initiate a full-text search. The use of predicates to specify criteria for the search in the WHERE clause of a query and the use of a CONTAINSTABLE or FREETEXTTABLE, which contains matching results and can be joined to the table to be searched. This generator uses a CONTAINSTABLE to represent all the functions offered by the query language in \ac{SQL}. This method is preferred to predicates because it allows getting a list of results, sorted by how much they match the search criteria, also called a rank. In addition, CONTAINSTABLE is preferred to FREETEXTTABLE, because FREETEXTTABLE is suitable for more fuzzy searches and less for searches that use defining functions to narrow down the results.\\
Based on these findings, a part of the SQL command can be preformulated with a few constants containing the metadata of the database (code \ref{code:sql-parts}, 7-10). So an INNER JOIN of the CONTAINSTABLE and the table to be searched is made, where the rank must be greater than five to weed out inaccurate matches (code \ref{code:sql-parts}, 29). From this, the title and rank are selected and sorted by rank in descending order. The top five results are then finally returned (code \ref{code:sql-parts}, 22). The exact specifications of the CONTAINSTABLE, which represent the search criteria, is the part that is filled by the generator (code \ref{code:sql-parts}, 26-28).
\begin{codeenv}
    \captionof{mycapcode}{Generate sql\_parts}
    \label{code:sql-parts}
    \lstinputlisting[language=Rust, linerange={6-10}]{code/code_gen/generator.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={20-29}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
Similar to the parser, the generator stores the list of statements and additionally the current and next statements as attributes, where the peek statement is used to check the end of the list. On initialization current and peek are set to \lstinline[language=Rust]$Statement::EoF$ (code \ref{code:gen-struct}, 45-46).
\begin{codeenv}
    \captionof{mycapcode}{Generator struct}
    \label{code:gen-struct}
    \lstinputlisting[language=Rust, linerange={33-48}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
The logic to iterate through the list is similar to that of the parser with the use of a next function which checks if the end of the list has already been reached (code \ref{code:write}, 52) and generates the next element if not and a write function which updates the current and peek attributes (code \ref{code:write}, 60-65).
\begin{codeenv}
    \captionof{mycapcode}{Generator write}
    \label{code:write}
    \lstinputlisting[language=Rust, linerange={50-66}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
In the code, three functions are used to generate all elements of an \ac{AST}. Similar to the parser, a distinction is made between statements and expressions and additionally operators.\\
The generate\_statement function is passed a statement to be generated (code \ref{code:gen-weight}, 71). Usually, this statement is one of the implemented functions of the query language, for example, weighted. In the case of the weighted function, the stored attribute 'parameter' is used to translate the statement into \ac{SQL} as follows. First, the \ac{SQL} function ISABOUT is called and a parenthesis is opened (code \ref{code:gen-weight}, 136). Then, for each tuple of search terms and their weights, the values are written down so that, for example, the values 'apple' and 0.4 give \lstinline[language=SQL]$apple WEIGHT (0.4),$ (code \ref{code:gen-weight}, 137-142). Finally, the last comma is deleted, the parenthesis of ISABOUT is closed, and all parts are combined into one string and returned(code \ref{code:gen-weight}, 143-145+150).
\begin{codeenv}
    \captionof{mycapcode}{Generate weighted}
    \label{code:gen-weight}
    \lstinputlisting[language=Rust, linerange={68-72}]{code/code_gen/generator.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={133-146}]{code/code_gen/generator.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={148-151}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
There is a special case in generate\_statement, infix operators, this case calls generate\_statement for the two statements and generate\_operator for the operator (code \ref{code:gen-in-stat}, 79-81) and combines the results.
\begin{codeenv}
    \captionof{mycapcode}{Generate infix operator statements}
    \label{code:gen-in-stat}
    \lstinputlisting[language=Rust, linerange={73-84}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
In the example above for generating weighted, the generate\_expression function was called in code listing \ref{code:gen-weight} in lines 138 and 139 to generate the search terms and weights. This function takes as input the expression it should generate and returns the value of the expression as a string if a normal expression was passed (code \ref{code:gen-expr}, 158-160).
\begin{codeenv}
    \captionof{mycapcode}{Generate expressions}
    \label{code:gen-expr}
    \lstinputlisting[language=Rust, linerange={153-160}]{code/code_gen/generator.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={186-188}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
If a form of an operator is passed as an expression, the corresponding generate function is called for the operators (code \ref{code:gen-op-expr}, 167+181) and the respective expressions are passed to the generate\_expression function. In the case of infix operators, parentheses are also set to safely represent the precedence as recognized by the parser (code \ref{code:gen-op-expr}, 164-170).\\
Something to pay attention to in \ac{SQL} is that if a NOT operator follows an infix operator, it must be written before the parenthesis, otherwise, \ac{SQL} throws a syntax error. To cover this case, infix operator generation checks if the second expression is a negation and rewrites the string in that case (code \ref{code:gen-op-expr}, 173-176).
\begin{codeenv}
    \captionof{mycapcode}{Generate operator expressions}
    \label{code:gen-op-expr}
    \lstinputlisting[language=Rust, linerange={161-185}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
The third and simplest generate function is generate\_operator, which translates operators into a string (code \ref{code:gen-op}, 195-196). Noticeable here is the NOT operator, which is already treated separately in code listing \ref{code:gen-op-expr} lines 173-176.
\begin{codeenv}
    \captionof{mycapcode}{Generate operators}
    \label{code:gen-op}
    \lstinputlisting[language=Rust, linerange={190-201}]{code/code_gen/generator.rs}
    \centerline{Source: generator.rs}
\end{codeenv}
All parts up to the generator combined already make up a working code generator for a custom query language. For example the input \lstinline[language=Fulltext-Search]$@contains:apple -tree: + @thesaurus:"human":$, the lexer converts into a list of tokens. The parser then interprets these tokens into an \ac{AST}, one exemplary representation can be seen in figure \ref{fig:ast-example}.
\begin{figure}[H]
    \caption{Parsed example AST}
    \label{fig:ast-example}
    \begin{forest}
        box/.style={sharp corners,
        draw=gray!50,
        fill=gray!20,
        },
        for tree={box,align=center,minimum width=80pt}
            [{Infix\\AND}
                    [Contains
                            [{Infix\\AND}
                                    [{WordOrPhrase\\apple}]
                                    [{Prefix\\NOT}
                                            [{WordOrPhrase\\tree}]
                                    ]
                            ]
                    ]
                    [Thesaurus
                            [{WordOrPhrase\\"human"}]
                    ]
            ]
    \end{forest}
    \\
    \centerline{Source: Own representation}
\end{figure}
The generator then takes the \ac{AST} and generates from it the \ac{SQL} in code listing \ref{code:sql-example}. Lines 1 to 9 and 11 to 14 are the more or less pre-formulated part using the constants of the test database. Line 10 is the intriguing part, which is generated from the passed functions and search criteria.
\begin{codeenv}
    \captionof{mycapcode}{Generated example SQL}
    \label{code:sql-example}
    \begin{lstlisting}[language=SQL]
USE Wikipedia;
SELECT TOP 5 *
FROM(
        SELECT FT_TBL.Title,
            KEY_TBL.RANK
        FROM [dbo].[Article] AS FT_TBL
            INNER JOIN CONTAINSTABLE(
                [dbo].[Article],
                *,
                ' ( apple ) AND NOT ( tree ) AND FORMSOF(THESAURUS,"human") '
            ) AS KEY_TBL ON FT_TBL.[ID] = KEY_TBL.[KEY]
        WHERE KEY_TBL.RANK > 5
    ) AS FS_RESULT
ORDER BY FS_RESULT.RANK DESC;
    \end{lstlisting}
    \centerline{Source: Own code generator}
\end{codeenv}