\subsection{Parsing operators and groups}
In addition to simple search terms and the call of a single function, the query language should also offer the possibility to logically link search terms and use several functions simultaneously. To make this possible, operators such as AND, OR, and NOT, and groups come into play. To interpret these types of operators and groups and store them as part of the \ac{AST}, there are separate types for them as both statement and expression. The statement enumeration (code \ref{code:op-enums}, 8-12) is used to allow the use of multiple functions in the query language, while the expression enumerations (code \ref{code:op-enums}, 40-41) are used to logically link search terms. The operators themselves are stored as a separate enumeration, with a function to translate tokens into operators (code \ref{code:op-enums}, 52-59).
\begin{codeenv}
    \captionof{mycapcode}{Operator statements and expressions}
    \label{code:op-enums}
    \lstinputlisting[language=Rust, linerange={3-12}]{code/code_gen/ast.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={33-36}]{code/code_gen/ast.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={40-60}]{code/code_gen/ast.rs}
    \centerline{Source: ast.rs}
\end{codeenv}
The big challenge with operators and groups is that it is no longer sufficient to process the token list linearly because operators are partly written after the affected tokens and hierarchies exist between the operators. For example, the AND operator has a stronger binding power than the OR operator, and groups, or parentheses, have an even higher binding power. This binding power is in text and code further called precedence.\\
Precedence is implemented as an ordered enumeration, which allows them to be compared and assigned higher or lower precedence. As with operators, there is a function to translate tokens into precedence (code \ref{code:precedence}, 37-51). The concept of precedence already appears in the code listings \ref{code:weighted} and \ref{code:parse-word} as an input variable for the functions parse\_statement and parse\_expression.
\begin{codeenv}
    \captionof{mycapcode}{Precedence}
    \label{code:precedence}
    \lstinputlisting[language=Rust, linerange={22-52}]{code/code_gen/parser.rs}
    \centerline{Source: parser.rs}
\end{codeenv}
Expression operators that are written before the token in question, such as the NOT operator, can be processed similarly to normal expressions. When the parser encounters one of the NOT tokens in parse\_expression (code \ref{code:not}, 171-177), an \lstinline[language=Rust]$Expression::Prefix$ is returned, where the actual search term is parsed with the parameter \lstinline[language=Rust]$Precedence::Prefix$, which is higher than the default \lstinline[language=Rust]$Precedence::Lowest$.
\begin{codeenv}
    \captionof{mycapcode}{Parse NOT}
    \label{code:not}
    \lstinputlisting[language=Rust, linerange={171-177}]{code/code_gen/parser.rs}
    \centerline{Source: parser.rs}
\end{codeenv}
More complicated are operators which are written after an affected token. For this, in parse\_expression after a token was parsed an attempt is made to parse a postfix or infix operator. At the same time, the precedence of the next token is compared to keep the corresponding hierarchies of the operators (code \ref{code:infix}, 189-197). The expression parsed so far is passed to the parse\_infix\_expression function and it structures it into an \lstinline[language=Rust]$Expression::Infix$, where the next search term is parsed again with the corresponding precedence.
\begin{codeenv}
    \captionof{mycapcode}{Parse infix operator}
    \label{code:infix}
    \lstinputlisting[language=Rust, linerange={188-197}]{code/code_gen/parser.rs}
    \vdots
    \lstinputlisting[language=Rust, linerange={220-238}]{code/code_gen/parser.rs}
    \centerline{Source: parser.rs}
\end{codeenv}
Postfix operators as such do not exist in the query language; instead, a search term written without an infix operator in between is parsed as a postfix AND (code \ref{code:postfix}, 203-218). So 'apple tree' is parsed as 'apple AND tree'. The second search term could potentially be negated, so the case 'apple -tree' is also covered and parsed as 'apple AND NOT tree'.
\begin{codeenv}
    \captionof{mycapcode}{Parse postfix operator}
    \label{code:postfix}
    \lstinputlisting[language=Rust, linerange={201-218}]{code/code_gen/parser.rs}
    \centerline{Source: parser.rs}
\end{codeenv}
